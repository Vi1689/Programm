#include <iostream>

// Функция вычисляет сумму цифр целого числа, используется передача по значению
int F13_val(int a) //  Параметр а - целое число
{
    int n = 0; //    Хранит текущее число
    int k = 0; //    Хранит последнюю цифру числа
    int s = 0; //    Накапливает сумму цифр

    // Начинаем с исходного числа и продолжаем пока число не стало нулём. После
    // каждой итерации отрезаем последнюю цифру
    for (n = a, s = 0; n != 0; n = n / 10) {
        k = n % 10; // Получаем последнюю цифру числа
        s = s + k; // Добавляем эту цифру к общей сумме
    }
    return s; // Возвращаем полученную сумму цифр по значению
}

// Функция вычисляет сумму цифр целого числа, используется передача по ссылке
void F13_ref(int& a, int& result) //  Параметр а - целое число, result -
                                  //  переменная для результата
{
    int n = 0; //    Хранит текущее число
    int k = 0; //    Хранит последнюю цифру числа
    int s = 0; //    Накапливает сумму цифр

    // Начинаем с исходного числа и продолжаем пока число не стало нулём. После
    // каждой итерации отрезаем последнюю цифру
    for (n = a, s = 0; n != 0; n = n / 10) {
        k = n % 10; // Получаем последнюю цифру числа
        s = s + k; // Добавляем эту цифру к общей сумме
    }
    result = s; // Возвращаем полученную сумму цифр по ссылке
}

// Функция вычисляет сумму цифр целого числа, используется передача по указателю
void F13_pointer(int* a, int* result) //  Параметр а - целое число, result -
                                      //  переменная для результата
{
    int n = 0; //    Хранит текущее число
    int k = 0; //    Хранит последнюю цифру числа
    int s = 0; //    Накапливает сумму цифр

    // Начинаем с исходного числа и продолжаем пока число не стало нулём. После
    // каждой итерации отрезаем последнюю цифру
    for (n = *a, s = 0; n != 0; n = n / 10) {
        k = n % 10; // Получаем последнюю цифру числа
        s = s + k; // Добавляем эту цифру к общей сумме
    }
    *result = s; // Возвращаем полученную сумму цифр по указателю
}

// Функция заполняет массив A простыми числами, меньшими заданного числа v,
// используется передача по значению
void F21_val(int A[], int v) // Параметр A[] - массив для заполнения, v - число
                             // до которого будем искать простые числа
{
    int i = 0; // Индекс для записи в массив A
    int a = 0; // Текущее проверяемое число
    int n = 0; // Делитель для проверки числа a на простоту

    // Перебираем все числа от 2 до v-1
    for (i = 0, a = 2; a < v; a++) {
        // Проверяем, делится ли a на какие-либо числа кроме 1 и себя
        for (n = 2; n < a; n++) {
            // Если делится без остатка - число не простое
            if (a % n == 0)
                break; // Выходим из внутреннего цикла
        }

        // Если внутренний цикл завершился без break
        // Значит, число простое - добавляем его в массив
        if (n == a)
            A[i++] = a; // Записываем число и увеличиваем индекс
    }

    // Помечаем конец данных нулём
    A[i] = 0;
}

// Функция заполняет массив A простыми числами, меньшими заданного числа v,
// используется передача по ссылке
void F21_ref(int A[], int& v) // Параметр A[] - массив для заполнения, v - число
                              // до которого будем искать простые числа
{
    int i = 0; // Индекс для записи в массив A
    int a = 0; // Текущее проверяемое число
    int n = 0; // Делитель для проверки числа a на простоту

    // Перебираем все числа от 2 до v-1
    for (i = 0, a = 2; a < v; a++) {
        // Проверяем, делится ли a на какие-либо числа кроме 1 и себя
        for (n = 2; n < a; n++) {
            // Если делится без остатка - число не простое
            if (a % n == 0)
                break; // Выходим из внутреннего цикла
        }

        // Если внутренний цикл завершился без break
        // Значит, число простое - добавляем его в массив
        if (n == a)
            A[i++] = a; // Записываем число и увеличиваем индекс
    }

    // Помечаем конец данных нулём
    A[i] = 0;
}

// Функция заполняет массив A простыми числами, меньшими заданного числа v,
// используется передача по указателю
void F21_pointer(
        int A[], int* v) // Параметр A[] - массив для заполнения, v - число до
                         // которого будем искать простые числа
{
    int i = 0; // Индекс для записи в массив A
    int a = 0; // Текущее проверяемое число
    int n = 0; // Делитель для проверки числа a на простоту

    // Перебираем все числа от 2 до v-1
    for (i = 0, a = 2; a < *v; a++) {
        // Проверяем, делится ли a на какие-либо числа кроме 1 и себя
        for (n = 2; n < a; n++) {
            // Если делится без остатка - число не простое
            if (a % n == 0)
                break; // Выходим из внутреннего цикла
        }

        // Если внутренний цикл завершился без break
        // Значит, число простое - добавляем его в массив
        if (n == a)
            A[i++] = a; // Записываем число и увеличиваем индекс
    }

    // Помечаем конец данных нулём
    A[i] = 0;
}

// Функция находит индекс элемента массива, который встречается наибольшее
// количество раз. Если таких элементов несколько, возвращает индекс первого из
// них. Используется передача по значению
int F37_val(int c[], int n) // Параметр c[] - массив в котором будем вести
                            // поиск, n - размер массива
{
    int s = 0; // Максимальное количество повторений, найденное на текущий
               // момент
    int i = 0; // Индекс текущего элемента для проверки
    int m = 0; // Счётчик повторений текущего элемента
    int j = 0; // Индекс для сравнения с другими элементами
    int b = 0; // Индекс элемента с максимальным количеством повторений

    // Перебираем все элементы массива, кроме последнего
    for (i = 0; i < n - 1; i++) {
        // Сравниваем текущий элемент c[i] со всеми последующими
        for (j = i + 1, m = 0; j < n; j++) {
            // Если находим совпадение, увеличиваем счётчик повторений
            if (c[i] == c[j])
                m++;
        }

        // Если количество повторений текущего элемента больше известного
        // максимума
        if (m > s) {
            s = m; // Обновляем максимальное количество повторений
            b = i; // Запоминаем индекс этого элемента
        }
    }

    // Возвращаем индекс элемента с наибольшим количеством повторений по
    // значению
    return b;
}

// Функция находит индекс элемента массива, который встречается наибольшее
// количество раз. Если таких элементов несколько, возвращает индекс первого из
// них. Используется передача по ссыдке
void F37_ref(
        int c[],
        int& n,
        int& result) // Параметр c[] - массив в котором будем вести поиск, n -
                     // размер массива, result - переменная для результата
{
    int s = 0; // Максимальное количество повторений, найденное на текущий
               // момент
    int i = 0; // Индекс текущего элемента для проверки
    int m = 0; // Счётчик повторений текущего элемента
    int j = 0; // Индекс для сравнения с другими элементами
    int b = 0; // Индекс элемента с максимальным количеством повторений

    // Перебираем все элементы массива, кроме последнего
    for (i = 0; i < n - 1; i++) {
        // Сравниваем текущий элемент c[i] со всеми последующими
        for (j = i + 1, m = 0; j < n; j++) {
            // Если находим совпадение, увеличиваем счётчик повторений
            if (c[i] == c[j])
                m++;
        }

        // Если количество повторений текущего элемента больше известного
        // максимума
        if (m > s) {
            s = m; // Обновляем максимальное количество повторений
            b = i; // Запоминаем индекс этого элемента
        }
    }

    // Возвращаем индекс элемента с наибольшим количеством повторений по ссылке
    result = b;
}

// Функция находит индекс элемента массива, который встречается наибольшее
// количество раз. Если таких элементов несколько, возвращает индекс первого из
// них. Используется передача по указателю
void F37_pointer(
        int c[],
        int* n,
        int* result) // Параметр c[] - массив в котором будем вести поиск, n -
                     // размер массива, result - переменная для результата
{
    int s = 0; // Максимальное количество повторений, найденное на текущий
               // момент
    int i = 0; // Индекс текущего элемента для проверки
    int m = 0; // Счётчик повторений текущего элемента
    int j = 0; // Индекс для сравнения с другими элементами
    int b = 0; // Индекс элемента с максимальным количеством повторений

    // Перебираем все элементы массива, кроме последнего
    for (i = 0; i < *n - 1; i++) {
        // Сравниваем текущий элемент c[i] со всеми последующими
        for (j = i + 1, m = 0; j < *n; j++) {
            // Если находим совпадение, увеличиваем счётчик повторений
            if (c[i] == c[j])
                m++;
        }

        // Если количество повторений текущего элемента больше известного
        // максимума
        if (m > s) {
            s = m; // Обновляем максимальное количество повторений
            b = i; // Запоминаем индекс этого элемента
        }
    }

    // Возвращаем индекс элемента с наибольшим количеством повторений по
    // указателю
    *result = b;
}

//  Функция ищет индекс наименьшего положительного элемента в массиве. Если
//  таких элементов несколько, возвращает индекс первого из них. Используется
//  передача по значению
int F49_val(int A[]) // Параметр A[] - входной массив из 10 целых чисел
{
    int i = 0; // Счётчик цикла
    int k = 0; // Индекс наименьшего положительного элемента

    // Проходим по всем элементам массива
    for (i = 0, k = -1; i < 10; i++) {
        // Пропускаем отрицательные элементы
        if (A[i] < 0)
            continue;

        // Если это первый найденный положительный элемент, запоминаем его
        // индекс
        if (k == -1) {
            k = i;
        }
        // Иначе сравниваем с текущим минимальным положительным
        else if (A[i] < A[k]) {
            k = i; // Обновляем индекс минимального
        }
    }

    // Возвращаем результат по значению:
    // - индекс наименьшего положительного элемента
    // - или -1, если положительных элементов нет
    return k;
}

//  Функция ищет индекс наименьшего положительного элемента в массиве. Если
//  таких элементов несколько, возвращает индекс первого из них. Используется
//  передача по ссылке
void F49_ref(int A[], int& result) // Параметр A[] - входной массив из 10 целых
                                   // чисел, result - переменная для результата
{
    int i = 0; // Счётчик цикла
    int k = 0; // Индекс наименьшего положительного элемента

    // Проходим по всем элементам массива
    for (i = 0, k = -1; i < 10; i++) {
        // Пропускаем отрицательные элементы
        if (A[i] < 0)
            continue;

        // Если это первый найденный положительный элемент, запоминаем его
        // индекс
        if (k == -1) {
            k = i;
        }
        // Иначе сравниваем с текущим минимальным положительным
        else if (A[i] < A[k]) {
            k = i; // Обновляем индекс минимального
        }
    }

    // Возвращаем результат по ссылке:
    // - индекс наименьшего положительного элемента
    // - или -1, если положительных элементов нет
    result = k;
}

//  Функция ищет индекс наименьшего положительного элемента в массиве. Если
//  таких элементов несколько, возвращает индекс первого из них. Используется
//  передача по указателю
void F49_pointer(
        int A[], int* result) // Параметр A[] - входной массив из 10 целых
                              // чисел, result - переменная для результата
{
    int i = 0; // Счётчик цикла
    int k = 0; // Индекс наименьшего положительного элемента

    // Проходим по всем элементам массива
    for (i = 0, k = -1; i < 10; i++) {
        // Пропускаем отрицательные элементы
        if (A[i] < 0)
            continue;

        // Если это первый найденный положительный элемент, запоминаем его
        // индекс
        if (k == -1) {
            k = i;
        }
        // Иначе сравниваем с текущим минимальным положительным
        else if (A[i] < A[k]) {
            k = i; // Обновляем индекс минимального
        }
    }

    // Возвращаем результат по указателю:
    // - индекс наименьшего положительного элемента
    // - или -1, если положительных элементов нет
    *result = k;
}

// Функция подсчитывает количество пар отрицательное, положительное числа идущих
// дрг за другом. Используется передача по значению
int F58_val(int A[]) // Парамент - A[] - входной массив из 10 целых чисел
{
    int i; // Счётчик цикла
    int s = 0; // Счётчик искомых положительных элементов
    bool k = 0; // Флаг: 1 - если предыдущий элемент был отрицательным

    // Проходим по всем элементам массива
    for (i = 0; i < 10; i++) {
        // Если текущий элемент отрицательный
        if (A[i] < 0) {
            k = 1; // Устанавливаем флаг в 1
        }
        // Если текущий элемент положительный
        else {
            // Если предыдущий элемент был отрицательный
            if (k == 1) {
                s++; // Увеличиваем счётчик
            }
            k = 0; // Сбрасываем флаг
        }
    }

    // Возвращаем количество найденных пар по значению
    return s;
}

// Функция подсчитывает количество пар отрицательное, положительное числа идущих
// дрг за другом. Используется передача по ссылке
void F58_ref(
        int A[], int& result) // Парамент - A[] - входной массив из 10 целых
                              // чисел, result - переменная для результата
{
    int i; // Счётчик цикла
    int s = 0; // Счётчик искомых положительных элементов
    bool k = 0; // Флаг: 1 - если предыдущий элемент был отрицательным

    // Проходим по всем элементам массива
    for (i = 0; i < 10; i++) {
        // Если текущий элемент отрицательный
        if (A[i] < 0) {
            k = 1; // Устанавливаем флаг в 1
        }
        // Если текущий элемент положительный
        else {
            // Если предыдущий элемент был отрицательный
            if (k == 1) {
                s++; // Увеличиваем счётчик
            }
            k = 0; // Сбрасываем флаг
        }
    }

    // Возвращаем количество найденных пар по ссылке
    result = s;
}

// Функция подсчитывает количество пар отрицательное, положительное числа идущих
// дрг за другом. Используется передача по указателю
void F58_pointer(
        int A[], int* result) // Парамент - A[] - входной массив из 10 целых
                              // чисел, result - переменная для результата
{
    int i; // Счётчик цикла
    int s = 0; // Счётчик искомых положительных элементов
    bool k = 0; // Флаг: 1 - если предыдущий элемент был отрицательным

    // Проходим по всем элементам массива
    for (i = 0; i < 10; i++) {
        // Если текущий элемент отрицательный
        if (A[i] < 0) {
            k = 1; // Устанавливаем флаг в 1
        }
        // Если текущий элемент положительный
        else {
            // Если предыдущий элемент был отрицательный
            if (k == 1) {
                s++; // Увеличиваем счётчик
            }
            k = 0; // Сбрасываем флаг
        }
    }

    // Возвращаем количество найденных пар по указателю
    *result = s;
}

int main()
{
    {
        int a = 123, res_val, res_ref, res_pointer;
        res_val = F13_val(a);
        F13_ref(a, res_ref);
        F13_pointer(&a, &res_pointer);
        std::cout << "//"
                     "--------------------------------------------------------"
                     "13\n";
        std::cout << "F13_val_1 - " << res_val << "\nF13_ref_1 - " << res_ref
                  << "\nF13_pointer_1 - " << res_pointer << "\n";
        a = 4231;
        res_val = F13_val(a);
        F13_ref(a, res_ref);
        F13_pointer(&a, &res_pointer);
        std::cout << "//"
                     "---------------------------------------------------------"
                     "-\n";
        std::cout << "F13_val_2 - " << res_val << "\nF13_ref_2 - " << res_ref
                  << "\nF13_pointer_2 - " << res_pointer << "\n";
    }

    {
        int A[100]{0}, v = 100;
        F21_val(A, v);
        std::cout << "//"
                     "--------------------------------------------------------"
                     "21\n";
        std::cout << "F21_val_1 - ";
        for (const auto i : A) {
            if (i == 0)
                break;
            std::cout << i << " ";
        }
        std::cout << "\n";
        F21_ref(A, v);
        std::cout << "F21_ref_1 - ";
        for (const auto i : A) {
            if (i == 0)
                break;
            std::cout << i << " ";
        }
        std::cout << "\n";
        F21_pointer(A, &v);
        std::cout << "F21_pointer_1 - ";
        for (const auto i : A) {
            if (i == 0)
                break;
            std::cout << i << " ";
        }
        std::cout << "\n";
        v = 200;
        F21_val(A, v);
        std::cout << "//"
                     "---------------------------------------------------------"
                     "-\n";
        std::cout << "F21_val_2 - ";
        for (const auto i : A) {
            if (i == 0)
                break;
            std::cout << i << " ";
        }
        std::cout << "\n";
        F21_ref(A, v);
        std::cout << "F21_ref_2 - ";
        for (const auto i : A) {
            if (i == 0)
                break;
            std::cout << i << " ";
        }
        std::cout << "\n";
        F21_pointer(A, &v);
        std::cout << "F21_pointer_2 - ";
        for (const auto i : A) {
            if (i == 0)
                break;
            std::cout << i << " ";
        }
        std::cout << "\n";
    }

    {
        int c[]{1, 2, 3, 4, 5, 6, 1, 1, 7, 8}, res_val, res_ref, res_pointer,
                n = sizeof(c) / sizeof(c[0]);
        res_val = F37_val(c, n);
        F37_ref(c, n, res_ref);
        F37_pointer(c, &n, &res_pointer);
        std::cout << "//"
                     "--------------------------------------------------------"
                     "37\n";
        std::cout << "F37_val_1 - " << res_val << "\nF37_ref_1 - " << res_ref
                  << "\nF37_pointer_1 - " << res_pointer << "\n";
        for (int i = 5; i < 10; ++i) {
            c[i] = 100;
        }
        res_val = F37_val(c, n);
        F37_ref(c, n, res_ref);
        F37_pointer(c, &n, &res_pointer);
        std::cout << "//"
                     "---------------------------------------------------------"
                     "-\n";
        std::cout << "F37_val_2 - " << res_val << "\nF37_ref_2 - " << res_ref
                  << "\nF37_pointer_2 - " << res_pointer << "\n";
    }

    {
        int A[]{100, 20, 3, 4, 5, 6, 10, 8, 7, 2}, res_val, res_ref,
                res_pointer;
        res_val = F49_val(A);
        F49_ref(A, res_ref);
        F49_pointer(A, &res_pointer);
        std::cout << "//"
                     "--------------------------------------------------------"
                     "49\n";
        std::cout << "F49_val_1 - " << res_val << "\nF49_ref_1 - " << res_ref
                  << "\nF49_pointer_1 - " << res_pointer << "\n";
        A[3] = 1;
        res_val = F49_val(A);
        F49_ref(A, res_ref);
        F49_pointer(A, &res_pointer);
        std::cout << "//"
                     "---------------------------------------------------------"
                     "-\n";
        std::cout << "F49_val_2 - " << res_val << "\nF49_ref_2 - " << res_ref
                  << "\nF49_pointer_2 - " << res_pointer << "\n";
    }

    {
        int A[]{-1, 2, -3, 4, -5, 6, -7, 8, -9, 10}, res_val, res_ref,
                res_pointer;
        res_val = F58_val(A);
        F58_ref(A, res_ref);
        F58_pointer(A, &res_pointer);
        std::cout << "//"
                     "--------------------------------------------------------"
                     "58\n";
        std::cout << "F58_val_1 - " << res_val << "\nF58_ref_1 - " << res_ref
                  << "\nF58_pointer_1 - " << res_pointer << "\n";
        A[1] *= -1;
        A[3] *= -1;
        res_val = F58_val(A);
        F58_ref(A, res_ref);
        F58_pointer(A, &res_pointer);
        std::cout << "//"
                     "---------------------------------------------------------"
                     "-\n";
        std::cout << "F58_val_2 - " << res_val << "\nF58_ref_2 - " << res_ref
                  << "\nF58_pointer_2 - " << res_pointer << "\n";
        std::cout << "//"
                     "---------------------------------------------------------"
                     "-\n";
    }

    return 0;
}